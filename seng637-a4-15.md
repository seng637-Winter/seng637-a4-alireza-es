**SENG 637 - Dependability and Reliability of Software Systems**

**Lab. Report \#4 â€“ Mutation Testing and Web app testing**

| Group \#:      | 15 |
| -------------- | --- |
| Student Names: |Mehrnaz Senobari|
|                |Sina Salimian|
|                |Sahar Hajjar Zadeh|
|                |Zar Safari|
|                |Fatemeh Ghaffarpour|
|                |Alireza Esmaeili|

# Introduction

Mutation testing is important for checking how good our test suites are. It works by making small changes, called mutants, in the software code to test if the test suite can find these changes. We focused on using mutation testing for the `Range` and `DataUtilities` classes from the JFreeChart library, which we already worked on in Assignment 3.

Before starting with mutation testing, we needed to make sure that our test suite was working well and that all test cases were passing. We found some problems in our `RangeTest.java` and `DataUtilitiesTest.java` test cases. Fixing these problems was important to make sure our test suite was ready for mutation testing.

We also did GUI and web testing using Selenium, a tool for automating web browsers. This part of our work involved making and automating test scenarios for web functionalities. Working with Selenium was a new experience that taught us a lot about web testing.

This report talks about how we improved our test suites with mutation testing and our experiences with GUI and web testing using Selenium. We will share the steps we took, the challenges we faced, and what we learned about making our testing better.


# Analysis of 10 Mutants of the Range class 

In this part of our report, we look closely at some changes, called mutants, that were automatically made to the `Range` class. We concentrated on mutations in two methods: `getCentralValue` and `constrain`.

### getCentralValue Method

The `getCentralValue` method is designed to calculate the middle number of the range. It works by adding half of the lowest number of the range to half of the highest number.

![getCentralValue Method](report-media/code1.png) *Figure: Original `getCentralValue` method.*

Some of the mutants we found in this method include:

1. **Changing Division to Multiplication**: One mutant replaced the division by 2.0 with multiplication. This made the method give back a number much bigger than the actual central value, which our tests were able to catch.
   
2. **Swapping Addition and Subtraction**: Another mutant changed the addition to subtraction. Instead of adding the halves of the lower and upper values, it subtracted them, which would result in an incorrect value if the range did not center around zero.

3. **Altering the Numeric Value**: A mutant changed the `2.0` to another number like `3.0`. This would alter the calculation and not return the correct central value.

Each of these mutants helped us see if our tests for `getCentralValue` were strong. Our tests needed to make sure that no matter what changes were made to the method, they could detect if the central value was not being calculated correctly. 

In the following sections, we will also discuss the `constrain` method and the mutants generated for it.


# Report all the statistics and the mutation score for each test class

# Analysis drawn on the effectiveness of each of the test classes

# A discussion on the effect of equivalent mutants on mutation score accuracy

# A discussion of what could have been done to improve the mutation score of the test suites

# Why do we need mutation testing? Advantages and disadvantages of mutation testing

# Explain your SELENUIM test case design process

# Explain the use of assertions and checkpoints

# how did you test each functionaity with different test data

# How the team work/effort was divided and managed

# Difficulties encountered, challenges overcome, and lessons learned

# Comments/feedback on the assignment itself
